####### 2025-10-22 (revert: do NOT auto-run remove.invar; detect invariant characters including one-state+ambiguity and STOP with guidance)
##### RHI: unified function (requires user preprocessing; authoritative invariant detection that stops and asks user to run remove.invar)
#
# V2.2
# Behavior summary:
# - If the user supplies a phyDat, RHI treats it as authoritative and will NOT run the curly-brace regex check.
# - If the user supplies a raw matrix/data.frame, RHI will check for curly-brace uncertainties (e.g. "{01}")
#   and stop with guidance to preprocess (uncert.to.poly or uncert.to.amb).
# - RHI now performs a robust invariant-site detection (including columns that have exactly one
#   non-'?' state plus any number of '?'s) by scanning columns as strings. If any invariant
#   characters are detected, RHI stops and instructs the user to run remove.invar() before retrying.
# - RHI does NOT call remove.invar() itself or remove invariant sites automatically.
#
RHI <- function(data, tree, n = 100, trees = FALSE, ordered = NULL, cost = NULL, per.char = FALSE){
  # Dependencies
  if(!requireNamespace("phangorn", quietly = TRUE)) stop("phangorn package required.")
  if(!requireNamespace("ape", quietly = TRUE)) stop("ape package required.")

  # Required helper functions expected in Functions/
  if(!exists("get.states", mode = "function")) stop("get.states() not found — make sure Functions/get.states is sourced or the package is loaded.")
  if(!exists("statef", mode = "function")) stop("statef() not found — make sure Functions/statef is sourced or the package is loaded.")
  morph_phydat_available <- exists("morph.phydat", mode = "function")
  uncert_to_amb_available <- exists("uncert.to.amb", mode = "function")
  uncert_to_poly_available <- exists("uncert.to.poly", mode = "function")
  cost_matrix_available <- exists("cost.matrix", mode = "function")
  # We do not require remove.invar here because RHI will instruct the user to run it if invariants are found.

  # --- Input handling: treat phyDat specially ---
  input_is_phyDat <- inherits(data, "phyDat")

  if(input_is_phyDat){
    # If the user supplied a phyDat, treat it as authoritative.
    data_phyDat <- data
    # Build a taxa x characters matrix for invariant detection/cost building
    data_matrix_check <- t(as.data.frame(data_phyDat))
  } else {
    # Coerce raw input to matrix for checks
    data_matrix_raw <- tryCatch({
      as.matrix(data)
    }, error = function(e){
      tryCatch(as.matrix(as.data.frame(data)), error = function(e2) stop("Unable to coerce 'data' to a matrix for preprocessing checks."))
    })

    # Detect curly-brace uncertainties ONLY (e.g. "{01}"). Do NOT flag round-parenthesis polymorphisms "(01)".
    uncertainty_pattern_curly <- "\\{[^}]+\\}"
    if(any(grepl(uncertainty_pattern_curly, data_matrix_raw, perl = TRUE))){
      guidance <- "Uncertainty notation (curly braces) detected in input (e.g. '{01}').\n"
      guidance <- paste0(guidance, "Please preprocess your data before calling RHI. Two common options:\n\n")
      guidance <- paste0(guidance, "1) Convert uncertainties to polymorphisms (retain multiple possible states):\n")
      if(uncert_to_poly_available){
        guidance <- paste0(guidance, "   matrix2 <- uncert.to.poly(matrix)\n   phydat  <- morph.phydat(matrix2)\n   RHI(phydat, tree, n)\n\n")
      } else {
        guidance <- paste0(guidance, "   matrix2 <- uncert.to.poly(matrix)  # ensure uncert.to.poly() is available\n   phydat  <- morph.phydat(matrix2)\n   RHI(phydat, tree, n)\n\n")
      }
      if(uncert_to_amb_available){
        guidance <- paste0(guidance, "2) Convert uncertainties to ambiguities '?' (keeps round-parenthesis polymorphisms intact):\n")
        guidance <- paste0(guidance, "   matrix2 <- uncert.to.amb(matrix)\n   phydat  <- morph.phydat(matrix2)\n   RHI(phydat, tree, n)\n\n")
      } else {
        guidance <- paste0(guidance, "2) Optionally, convert uncertainties to ambiguities '?' using uncert.to.amb() if available in your environment (keeps polymorphisms intact).\n\n")
      }
      guidance <- paste0(guidance, "Choose the preprocessing that matches your intended treatment of uncertainties.")
      stop(guidance)
    }

    # Use the (user-supplied, preprocessed) matrix for checks
    data_matrix_check <- data_matrix_raw
    data_phyDat <- NULL
  }

  # Ensure the check-matrix is a character matrix
  if(is.data.frame(data_matrix_check)) data_matrix_check <- as.matrix(data_matrix_check)
  if(!is.matrix(data_matrix_check)) stop("Internal error: data could not be coerced to a matrix for invariant checks.")
  data_matrix_check[] <- as.character(data_matrix_check)

  # --- Robust invariant-site detection (string-based) ---
  nchar_check <- ncol(data_matrix_check)
  if(is.null(nchar_check) || nchar_check == 0){
    stop("No characters found in the input data.")
  }

  invariant_idxs <- integer(0)
  for(i in seq_len(nchar_check)){
    colvals <- data_matrix_check[, i]
    # treat NA and '?' as ambiguity
    nonamb <- colvals[!is.na(colvals) & colvals != "?"]
    # If no non-ambiguous values (all '?' or NA) -> invariant
    if(length(nonamb) == 0){
      invariant_idxs <- c(invariant_idxs, i)
      next
    }
    # If only a single distinct non-ambiguous value -> invariant (covers one-state + ambiguities)
    if(length(unique(nonamb)) <= 1){
      invariant_idxs <- c(invariant_idxs, i)
    }
  }
  invariant_idxs <- sort(unique(invariant_idxs))

  if(length(invariant_idxs) > 0){
    # Build helpful message and stop: ask user to run remove.invar() before re-running RHI
    if(!is.null(colnames(data_matrix_check))){
      bad_names <- colnames(data_matrix_check)[invariant_idxs]
      stop(sprintf("Invariant characters detected (including one-state + ambiguity). These would be removed: %s. Please remove invariant characters (e.g. using remove.invar()) before running RHI.", paste(bad_names, collapse = ", ")))
    } else {
      stop(sprintf("Invariant characters detected at column indices: %s. Please remove invariant characters (e.g. using remove.invar()) before running RHI.", paste(invariant_idxs, collapse = ", ")))
    }
  }

  # --- From this point, no invariant characters detected and no curly-brace uncertainties found ---
  # Prepare phyDat for downstream analysis
  if(is.null(data_phyDat)){
    if(!morph_phydat_available) stop("data is not a phyDat object and morph.phydat() was not found. Supply a phyDat or ensure morph.phydat() is available.")
    # build phyDat from the user-supplied (preprocessed) matrix
    data_phyDat <- morph.phydat(data_matrix_check)
  }

  # Normalize ordered argument (names -> indices)
  if(!is.null(ordered)){
    if(is.character(ordered)){
      coln <- colnames(data_matrix_check)
      if(is.null(coln)) stop("data has no column names; supply ordered as numeric indices.")
      idx <- match(ordered, coln)
      if(any(is.na(idx))) stop("Some ordered character names not found in data column names.")
      ordered_idx <- sort(unique(idx))
    } else if(is.numeric(ordered)){
      if(any(ordered < 1 | ordered > nchar_check)) stop("ordered indices out of range.")
      ordered_idx <- sort(unique(as.integer(ordered)))
    } else {
      stop("ordered must be NULL, a numeric vector of indices, or a character vector of column names.")
    }
  } else {
    ordered_idx <- integer(0)
  }

  # Precompute default cost matrix once from the processed data matrix if needed later
  default_cost_matrix <- NULL
  if(is.null(cost) && length(ordered_idx) > 0 && cost_matrix_available){
    default_cost_matrix <- cost.matrix(data_matrix_check)
  }

  # Helper: randomize tip labels while preserving topology
  rtips <- function(tr){
    new_tips <- sample(tr$tip.label)
    Rtree <- tr
    Rtree$tip.label <- new_tips
    return(Rtree)
  }

  # Compute lmin from phyDat using original algorithm (phyDat -> t(as.data.frame(phyDat)))
  compute_lmin_matrix <- function(phyDat_obj){
    mat <- t(as.data.frame(phyDat_obj))
    states <- get.states(mat)
    f <- statef(mat)
    lmin_list <- vector("numeric", length(f))
    for(l in seq_along(f)){
      lmin_list[[l]] <- ((as.numeric(states)[l+1]) * (f[l] * dim(mat)[2]))
    }
    lmin <- sum(as.numeric(na.omit(lmin_list)))
    return(lmin)
  }

  compute_lmin_per_char <- function(matrix_data){
    nchar_local <- ncol(matrix_data)
    lmin_chars <- integer(nchar_local)
    for(k in seq_len(nchar_local)){
      states_k <- get.states(matrix_data[, k, drop = FALSE])
      lmin_chars[k] <- length(states_k) - 1
    }
    return(lmin_chars)
  }

  build_char_phyDat_list <- function(phyDat_obj, nchar_local){
    char_list <- vector("list", nchar_local)
    for(i in seq_len(nchar_local)){
      char_list[[i]] <- tryCatch(
        phyDat_obj[, i, drop = FALSE],
        error = function(e) stop(sprintf("Failed to subset phyDat for character %d. phangorn phyDat subsetting failed with: %s", i, e$message))
      )
    }
    return(char_list)
  }

  compute_RHI_per_char_single_tree <- function(matrix_data, phyDat_obj, tr, n_random, ordered_idx_local){
    nchar_local <- ncol(matrix_data)
    char_phy_list <- build_char_phyDat_list(phyDat_obj, nchar_local)

    lmin_chars <- compute_lmin_per_char(matrix_data)
    random_trees <- replicate(n_random, rtips(tr), simplify = FALSE)

    null_tlengths_char <- vector("list", nchar_local)
    for(m in seq_len(nchar_local)){
      states_m <- get.states(matrix_data[, m, drop = FALSE])
      nstates <- length(states_m)
      if((m %in% ordered_idx_local) && nstates > 1){
        cost_m <- if(!is.null(cost)) cost else cost.matrix(states_m)
        null_tlengths_char[[m]] <- unlist(lapply(random_trees, function(rt){
          phangorn::parsimony(rt, char_phy_list[[m]], method = "sankoff", cost = cost_m)
        }))
      } else {
        null_tlengths_char[[m]] <- unlist(lapply(random_trees, function(rt){
          phangorn::parsimony(rt, char_phy_list[[m]])
        }))
      }
    }

    Lnull_char_med <- as.numeric(sapply(null_tlengths_char, function(x) stats::quantile(x, prob = 0.5)))

    char_lengths <- numeric(nchar_local)
    for(b in seq_len(nchar_local)){
      states_b <- get.states(matrix_data[, b, drop = FALSE])
      nstates_b <- length(states_b)
      if((b %in% ordered_idx_local) && nstates_b > 1){
        cost_b <- if(!is.null(cost)) cost else cost.matrix(states_b)
        char_lengths[b] <- phangorn::parsimony(tr, char_phy_list[[b]], method = "sankoff", cost = cost_b)
      } else {
        char_lengths[b] <- phangorn::parsimony(tr, char_phy_list[[b]])
      }
    }

    char_lengths_minus_lmin <- char_lengths - lmin_chars
    Lnull_minus_lmin <- Lnull_char_med - lmin_chars
    RHI_char <- char_lengths_minus_lmin / Lnull_minus_lmin

    zero_denom <- (Lnull_minus_lmin == 0)
    RHI_char[zero_denom & (char_lengths_minus_lmin == 0)] <- 0
    RHI_char[zero_denom & (char_lengths_minus_lmin != 0)] <- NA
    RHI_char[is.nan(RHI_char)] <- 0

    coln <- colnames(matrix_data)
    if(!is.null(coln)) names(RHI_char) <- coln else names(RHI_char) <- paste0("char", seq_len(nchar_local))

    return(RHI_char)
  }

  compute_RHI_single_tree <- function(matrix_data, phyDat_obj, tr, n_random, ordered_idx_local){
    random_trees <- replicate(n_random, rtips(tr), simplify = FALSE)
    nchar_local <- ncol(matrix_data)

    if(length(ordered_idx_local) == 0){
      null_tlengths <- unlist(lapply(random_trees, function(rt) phangorn::parsimony(rt, phyDat_obj)))
    } else {
      if(!is.null(cost) && is.matrix(cost)){
        cost_used <- cost
      } else {
        if(is.null(default_cost_matrix)){
          if(!cost_matrix_available) stop("Ordered characters requested but cost.matrix() not available and no 'cost' supplied. Please supply a cost matrix or ensure functions/cost.matrix is available.")
          default_cost_matrix <- cost.matrix(matrix_data)
        }
        cost_used <- default_cost_matrix
      }

      ord_phy <- phyDat_obj[, ordered_idx_local, drop = FALSE]
      nonord_phy <- if(length(ordered_idx_local) < nchar_local) phyDat_obj[, -ordered_idx_local, drop = FALSE] else NULL

      null_tlengths <- unlist(lapply(random_trees, function(rt){
        Lord <- if(!is.null(ord_phy)) phangorn::parsimony(rt, ord_phy, method = "sankoff", cost = cost_used) else 0
        Lnon <- if(!is.null(nonord_phy)) phangorn::parsimony(rt, nonord_phy) else 0
        Lord + Lnon
      }))
    }

    Lnull <- stats::quantile(null_tlengths, prob = 0.5)
    Lnull5 <- stats::quantile(null_tlengths, prob = 0.05)
    Lnull95 <- stats::quantile(null_tlengths, prob = 0.95)

    lmin <- compute_lmin_matrix(phyDat_obj)

    if(length(ordered_idx_local) == 0){
      L <- phangorn::parsimony(tr, phyDat_obj)
    } else {
      if(!exists("cost_used")){
        if(is.null(default_cost_matrix) && !cost_matrix_available) stop("Ordered characters requested but cost.matrix() not available and no 'cost' supplied.")
        cost_used <- default_cost_matrix
      }
      ord_phy <- phyDat_obj[, ordered_idx_local, drop = FALSE]
      nonord_phy <- if(length(ordered_idx_local) < nchar_local) phyDat_obj[, -ordered_idx_local, drop = FALSE] else NULL
      L1 <- if(!is.null(ord_phy)) phangorn::parsimony(tr, ord_phy, method = "sankoff", cost = cost_used) else 0
      L2 <- if(!is.null(nonord_phy)) phangorn::parsimony(tr, nonord_phy) else 0
      L <- L1 + L2
    }

    RHI_low <- (L - lmin) / (Lnull95 - lmin)
    RHI_central <- (L - lmin) / (Lnull - lmin)
    RHI_high <- (L - lmin) / (Lnull5 - lmin)

    names(RHI_low) <- "5% quantile"
    names(RHI_central) <- "RHI"
    names(RHI_high) <- "95% quantile"
    names(L) <- "Tree Length"
    names(lmin) <- "Lmin"

    return(c(RHI_low, RHI_central, RHI_high, L, lmin))
  }

  # Main dispatch (multi-tree vs single-tree and per.char option)
  if(isTRUE(trees)){
    trees_list <- if(!is.null(trees_list_auto)) trees_list_auto else tree
    if(!(inherits(trees_list, "multiPhylo") || is.list(trees_list))) stop("When trees = TRUE, 'tree' must be a multiPhylo object or a list of phylo objects.")
    if(length(trees_list) < 1) stop("'tree' (multi) is empty.")

    if(per.char){
      per_tree_RHIs <- lapply(trees_list, function(tr){
        compute_RHI_per_char_single_tree(data_matrix_check, data_phyDat, tr, n, ordered_idx)
      })
      RHImat <- do.call(cbind, per_tree_RHIs)
      medians <- apply(RHImat, 1, function(x) stats::quantile(x, prob = 0.5, na.rm = TRUE))
      q05 <- apply(RHImat, 1, function(x) stats::quantile(x, prob = 0.05, na.rm = TRUE))
      q95 <- apply(RHImat, 1, function(x) stats::quantile(x, prob = 0.95, na.rm = TRUE))

      return(list(per_character_median = medians,
                  per_character_5pct = q05,
                  per_character_95pct = q95,
                  per_tree_values = per_tree_RHIs))
    } else {
      RHIs_per_tree <- t(sapply(trees_list, function(tr){
        compute_RHI_single_tree(data_matrix_check, data_phyDat, tr, n, ordered_idx)
      }, simplify = TRUE))

      col_names <- colnames(RHIs_per_tree)
      if(!"RHI" %in% col_names) stop("Unexpected internal format from compute_RHI_single_tree.")
      central_RHIs <- as.numeric(RHIs_per_tree[, "RHI"])
      L_values <- if("Tree Length" %in% col_names) as.numeric(RHIs_per_tree[, "Tree Length"]) else as.numeric(RHIs_per_tree[, 4])

      RHIs_med <- stats::quantile(central_RHIs, prob = 0.5, na.rm = TRUE)
      RHIs_05 <- stats::quantile(central_RHIs, prob = 0.05, na.rm = TRUE)
      RHIs_95 <- stats::quantile(central_RHIs, prob = 0.95, na.rm = TRUE)
      L_med <- stats::quantile(L_values, prob = 0.5, na.rm = TRUE)

      names(RHIs_05) <- "5% quantile"; names(RHIs_med) <- "median RHI"; names(RHIs_95) <- "95% quantile"; names(L_med) <- "median Tree Length"

      print(c(RHIs_05, RHIs_med, RHIs_95, L_med))
      return(list(RHI_5pct = RHIs_05, RHI_median = RHIs_med, RHI_95pct = RHIs_95, median_tree_length = L_med, per_tree_results = RHIs_per_tree))
    }
  }

  # Single-tree mode
  if(is.null(tree)) stop("No tree supplied. Provide 'tree' (a phylo), or set trees = TRUE and provide a list/multiPhylo as 'tree'.")
  if(!inherits(tree, "phylo")) stop("In single-tree mode (trees = FALSE), 'tree' must be a phylo object.")

  if(per.char){
    RHI_char <- compute_RHI_per_char_single_tree(data_matrix_check, data_phyDat, tree, n, ordered_idx)
    return(RHI_char)
  } else {
    out_vec <- compute_RHI_single_tree(data_matrix_check, data_phyDat, tree, n, ordered_idx)
    return(out_vec)
  }
}
