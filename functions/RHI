####### 2025-10-21 (fix: detect only curly-brace uncertainties { } — do not flag round-bracket polymorphisms)
##### RHI: unified function (fixed uncertainty detection)
#
# Key fix: earlier versions detected both "(01)" and "{01}" and stopped. This version
# detects curly-brace uncertainty notation only (e.g. "{01}"), and suggests uncert.to.poly()
# or uncert.to.amb() as preprocessing. Round-bracket polymorphisms "(01)" are NOT flagged.
#
RHI <- function(data, tree, n = 100, trees = FALSE, ordered = NULL, cost = NULL, per.char = FALSE){
  if(!requireNamespace("phangorn", quietly = TRUE)) stop("phangorn package required.")
  if(!requireNamespace("ape", quietly = TRUE)) stop("ape package required.")

  if(!exists("get.states", mode = "function")) stop("get.states() not found — make sure Functions/get.states is sourced or the package is loaded.")
  if(!exists("uncert.to.poly", mode = "function")) stop("uncert.to.poly() not found — make sure Functions/uncert.to.poly is sourced or the package is loaded.")
  uncert_to_amb_available <- exists("uncert.to.amb", mode = "function")
  if(!exists("statef", mode = "function")) stop("statef() not found — make sure Functions/statef is sourced or the package is loaded.")
  cost_matrix_available <- exists("cost.matrix", mode = "function")
  remove_invar_available <- exists("remove.invar", mode = "function")

  # --- Prepare raw input matrix (keep unmodified copy for checks) ---
  data_matrix_raw <- tryCatch({
    as.matrix(data)
  }, error = function(e){
    tryCatch(as.matrix(as.data.frame(data)), error = function(e2) stop("Unable to coerce 'data' to a matrix for preprocessing checks."))
  })

  # FIXED: detect curly-brace uncertainties ONLY (e.g. "{01}") and do NOT flag round parentheses "(01)"
  uncertainty_pattern_curly <- "\\{[0-9, ]+\\}"
  if(any(grepl(uncertainty_pattern_curly, data_matrix_raw, perl = TRUE))){
    guidance <- "Uncertainty notation (curly braces) detected in input (e.g. '{01}').\n"
    guidance <- paste0(guidance, "Please preprocess your data before calling RHI. Two common options:\n\n")
    guidance <- paste0(guidance, "1) Convert uncertainties to polymorphisms (retain multiple possible states):\n")
    guidance <- paste0(guidance, "   matrix2 <- uncert.to.poly(matrix)\n")
    guidance <- paste0(guidance, "   phydat  <- morph.phydat(matrix2)\n")
    guidance <- paste0(guidance, "   RHI(phydat, tree, n)\n\n")
    if(uncert_to_amb_available){
      guidance <- paste0(guidance, "2) Convert uncertainties to ambiguities '?' (keeps round-parenthesis polymorphisms intact):\n")
      guidance <- paste0(guidance, "   matrix2 <- uncert.to.amb(matrix)\n")
      guidance <- paste0(guidance, "   phydat  <- morph.phydat(matrix2)\n")
      guidance <- paste0(guidance, "   RHI(phydat, tree, n)\n\n")
    } else {
      guidance <- paste0(guidance, "2) Optionally, convert uncertainties to ambiguities '?' using uncert.to.amb() if available in your environment (keeps polymorphisms intact).\n\n")
    }
    guidance <- paste0(guidance, "Choose the preprocessing that matches your intended treatment of uncertainties.")
    stop(guidance)
  }

  # Now convert uncertainties to polymorphisms (safe because we've warned above if curly-brace notations remain)
  data_matrix <- uncert.to.poly(data_matrix_raw)
  nchar <- NCOL(data_matrix)

  # --- Invariant-site detection (silent if none found) ---
  invariant_detected <- FALSE
  removed_info <- NULL

  if(remove_invar_available){
    safe_noinv <- tryCatch(
      { withCallingHandlers(remove.invar(data_matrix), warning = function(w) invokeRestart("muffleWarning")) },
      error = function(e) NULL
    )
    if(!is.null(safe_noinv) && ncol(safe_noinv) < nchar){
      invariant_detected <- TRUE
      if(!is.null(colnames(data_matrix))){
        removed <- setdiff(colnames(data_matrix), colnames(safe_noinv))
        removed_info <- if(length(removed) > 0) paste(removed, collapse = ", ") else paste0(nchar - ncol(safe_noinv), " character(s)")
      } else {
        removed_info <- paste0(nchar - ncol(safe_noinv), " character(s)")
      }
    } else if(is.null(safe_noinv)){
      quick_invar <- sapply(seq_len(nchar), function(i){
        col <- data_matrix[, i]
        vals <- col[col != "?"]
        if(length(vals) == 0) return(FALSE)
        length(unique(vals)) == 1
      })
      if(any(quick_invar)){
        invariant_detected <- TRUE
        idxs <- which(quick_invar)
        removed_info <- if(!is.null(colnames(data_matrix))) paste(colnames(data_matrix)[idxs], collapse = ", ") else paste(idxs, collapse = ", ")
      }
    }
  } else {
    quick_invar <- sapply(seq_len(nchar), function(i){
      col <- data_matrix[, i]
      vals <- col[col != "?"]
      if(length(vals) == 0) return(FALSE)
      length(unique(vals)) == 1
    })
    if(any(quick_invar)){
      invariant_detected <- TRUE
      idxs <- which(quick_invar)
      removed_info <- if(!is.null(colnames(data_matrix))) paste(colnames(data_matrix)[idxs], collapse = ", ") else paste(idxs, collapse = ", ")
    }
  }

  if(invariant_detected){
    stop(sprintf("Invariant characters detected and would be removed: %s. Please remove them (e.g. using remove.invar()) before running RHI.", removed_info))
  }

  # convert to phyDat if not already (use morph.phydat wrapper) — use the processed matrix
  if(inherits(data, "phyDat")){
    data_phyDat <- data
  } else {
    if(exists("morph.phydat", mode = "function")){
      data_phyDat <- morph.phydat(data_matrix)
    } else {
      stop("data is not a phyDat object and morph.phydat() was not found. Supply a phyDat or ensure morph.phydat() is available.")
    }
  }

  # Compute default cost matrix once from processed data_matrix if needed later
  default_cost_matrix <- NULL
  if(is.null(cost) && length(ordered) > 0 && cost_matrix_available){
    default_cost_matrix <- cost.matrix(data_matrix)
  }

  # Auto-detect multiPhylo/list supplied as 'tree' => multi-tree mode
  if( (inherits(tree, "multiPhylo") || (is.list(tree) && length(tree) > 0 && all(sapply(tree, function(x) inherits(x, "phylo"))))) ){
    trees <- TRUE
    trees_list_auto <- tree
  } else {
    trees_list_auto <- NULL
  }

  # Normalize ordered argument (names -> indices)
  if(!is.null(ordered)){
    if(is.character(ordered)){
      coln <- colnames(data_matrix)
      if(is.null(coln)) stop("data has no column names; supply ordered as numeric indices.")
      idx <- match(ordered, coln)
      if(any(is.na(idx))) stop("Some ordered character names not found in data column names.")
      ordered_idx <- sort(unique(idx))
    } else if(is.numeric(ordered)){
      if(any(ordered < 1 | ordered > nchar)) stop("ordered indices out of range.")
      ordered_idx <- sort(unique(as.integer(ordered)))
    } else {
      stop("ordered must be NULL, a numeric vector of indices, or a character vector of column names.")
    }
  } else {
    ordered_idx <- integer(0)
  }

  # helper: randomize tip labels while preserving topology
  rtips <- function(tr){
    new_tips <- sample(tr$tip.label)
    Rtree <- tr
    Rtree$tip.label <- new_tips
    return(Rtree)
  }

  # compute_lmin_matrix, compute_lmin_per_char, build_char_phyDat_list,
  # compute_RHI_per_char_single_tree, compute_RHI_single_tree etc.
  # (omitted here for brevity — unchanged from previous implementation;
  #  keep the rest of the unified function as before.)
  #
  # For clarity: the rest of the function (parsimony calls, null distribution,
  # per-character option, multiPhylo support) is unchanged and will run as before.
  #
  # --- INSERT ORIGINAL WORKER FUNCTIONS HERE (unchanged) ---
  #
  # Single-tree / multi-tree dispatch and final return.
  #
  # (If you want the full file with all worker functions included, I can paste the complete function again.)
  #
  invisible(NULL)
}
