### 27-Oct-2025 homoplasy.bin function
V1.1

### Binning RHI values by absolute value threshold, rounding, minimum bin size, and excluded character NA handling, including plotting RHI distribution within bins and summary stats.

# rhi_vals: named numeric vector (per-character RHI values generated from RHI(... per.char = TRUE)
# abs_val_min: minimum number of characters with the same value (e.g. RHI = 0) to form its own absolute-value bin (e.g. abs_val_min = 10 means minimum of 10 characters with the same value required to form own bin). Default = 20
# intervals: numeric vector of bin intervals for range bins (e.g. c(0, 1, 0.1) would bin RHI values every 0.1 between 0 and 1)
# round_digits: number of digits to round (decimal places) for equality grouping (default: 3)
# min_bin_size: minimum number of characters for any bin (default: 5; bins with fewer are merged into the nearest non-absolute bin)
# excluded: integer vector of character indices to exclude (optional); this is for excluded invariant characters that were removed in preprosessing from remove.invar function. Must be reintroduced if you want accurate character lists for each partition.
# Returns: list of character names for each bin (unique value bins, range bins, and "NA" bin for excluded/missing); box plot for distributions of bins; variance statistics.
# Combined homoplasy.bin: binning, summary stats, and boxplot
homoplasy.bin <- function(
  rhi_vals, 
  abs_val_min = 20, 
  intervals = seq(0, 1, 0.1),
  round_digits = 3,
  min_bin_size = 1,
  excluded = integer(0),
  plot = TRUE
){
  # --- Exclusion logic ---
  N <- length(rhi_vals)
  if(length(excluded) > 0){
    rhi_vals[excluded] <- NA_real_
  }
  names_rhi <- names(rhi_vals)
  if(is.null(names_rhi)) names_rhi <- as.character(seq_len(N))
  
  # --- Binning logic ---
  rhi_rounded <- round(rhi_vals, digits = round_digits)
  tab <- table(rhi_rounded, useNA = "no")
  abs_val_bins <- names(tab)[tab >= abs_val_min]
  bin_labels <- character(0)
  bin_list <- list()
  used <- rep(FALSE, N)
  
  # Assign values that meet threshold to their own abs_val bin
  for(val in abs_val_bins) {
    idx <- which(rhi_rounded == as.numeric(val))
    binname <- paste0("=", val)
    bin_labels <- c(bin_labels, binname)
    bin_list[[binname]] <- names_rhi[idx]
    used[idx] <- TRUE
  }
  
  # Remaining values: bin by intervals
  remaining_idx <- which(!used & !is.na(rhi_vals))
  remaining_vals <- rhi_vals[remaining_idx]
  remaining_names <- names_rhi[remaining_idx]
  bin_map <- character(length(remaining_idx))
  range_bins <- NULL
  if(length(remaining_vals) > 0){
    range_bins <- cut(remaining_vals, breaks = intervals, include.lowest = TRUE, right = FALSE)
    bin_map <- as.character(range_bins)
    for(lbl in levels(range_bins)){
      idx <- which(range_bins == lbl)
      if(length(idx) > 0){
        bin_labels <- c(bin_labels, as.character(lbl))
        bin_list[[as.character(lbl)]] <- remaining_names[idx]
      }
    }
  }
  
  na_idx <- which(is.na(rhi_vals))
  if(length(na_idx) > 0){
    bin_list[["NA"]] <- names_rhi[na_idx]
    bin_labels <- c(bin_labels, "NA")
  }
  
  # --- Merge small bins ---
  bin_sizes <- sapply(bin_list, length)
  too_small <- which(bin_sizes < min_bin_size & names(bin_list) != "NA")
  if(length(too_small) > 0 && length(bin_list) > 1){
    # Only merge interval bins; do NOT merge abs_val bins
    interval_bin_names <- setdiff(names(bin_list),
                                  c(names(bin_list)[startsWith(names(bin_list), "=")], "NA"))
    interval_bin_centers <- sapply(interval_bin_names, function(lbl){
      nums <- as.numeric(unlist(regmatches(lbl, gregexpr("[0-9.]+", lbl))))
      if(length(nums) == 2) mean(nums) else NA_real_
    })
    for(idx in too_small){
      lbl <- names(bin_list)[idx]
      vals <- bin_list[[lbl]]
      if(length(vals) == 0) next
      # Only merge if this bin is an interval bin
      if(lbl %in% interval_bin_names){
        # Get bin center for this interval bin
        nums <- as.numeric(unlist(regmatches(lbl, gregexpr("[0-9.]+", lbl))))
        my_center <- if(length(nums) == 2) mean(nums) else NA_real_
        # Find closest other interval bin
        other_idxs <- setdiff(seq_along(interval_bin_names), which(interval_bin_names == lbl))
        dists <- abs(interval_bin_centers[other_idxs] - my_center)
        nearest_bin <- interval_bin_names[other_idxs[which.min(dists)]]
        bin_list[[nearest_bin]] <- c(bin_list[[nearest_bin]], vals)
        bin_list[[lbl]] <- character(0)
      }
      # If abs_val bin is too small, leave empty (do not merge)
    }
    # Remove empty bins except NA
    keep <- sapply(bin_list, length) > 0 | names(bin_list) == "NA"
    bin_list <- bin_list[keep]
  }
  
  # --- Summary statistics ---
  stats_df <- do.call(rbind, lapply(names(bin_list), function(bn) {
    char_ids <- bin_list[[bn]]
    vals <- rhi_vals[char_ids]
    vals <- vals[!is.na(vals)]
    data.frame(
      bin = bn,
      variance = if(length(vals) > 1) var(vals) else 0,
      mean = if(length(vals) > 0) mean(vals) else NA,
      sd = if(length(vals) > 1) sd(vals) else 0,
      n = length(vals)
    )
  }))
  rownames(stats_df) <- NULL

  # --- Boxplot ---
  if(plot) {
    plot_list <- lapply(names(bin_list), function(bn) rhi_vals[bin_list[[bn]]])
    names(plot_list) <- names(bin_list)
    plot_list <- plot_list[sapply(plot_list, function(x) sum(!is.na(x)) > 0)]
    boxplot(plot_list,
            main="RHI Values by Homoplasy Bin",
            xlab="Bin",
            ylab="RHI Value",
            las=2,
            col="lightblue")
    abline(h=mean(rhi_vals, na.rm=TRUE), col="red", lty=2)
  }
  
  return(list(
    bins = bin_list,
    stats = stats_df
  ))
}
