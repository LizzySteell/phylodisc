### 27-Oct-2025 homoplasy.bin function
V1.4

### Binning RHI values by absolute value threshold, rounding, minimum bin size, and excluded character NA handling, including plotting RHI distribution within bins and summary stats.
# This version ensures correct frame shift and unique naming when 'excluded' is specified,
# fixes plotting bug, and includes explicit comments that bins under min_bin_size are NOT merged into abs_val bins.

# rhi_vals: named numeric vector (per-character RHI values generated from RHI(... per.char = TRUE)
# abs_val_min: minimum number of characters with the same value (e.g. RHI = 0) to form its own absolute-value bin (e.g. abs_val_min = 10 means minimum of 10 characters with the same value required to form own bin). Default = 20
# intervals: numeric vector of bin intervals for range bins (e.g. c(0, 1, 0.1) would bin RHI values every 0.1 between 0 and 1)
# round_digits: number of digits to round (decimal places) for equality grouping (default: 3)
# min_bin_size: minimum number of characters for any bin (default: 5; bins with fewer are merged into the nearest non-absolute bin)
# excluded: integer vector of character indices to exclude (optional); this is for excluded invariant characters that were removed in preprosessing from remove.invar function. Must be reintroduced if you want accurate character lists for each partition.
# Returns: list of character names for each bin (unique value bins, range bins, and "NA" bin for excluded/missing); box plot for distributions of bins; variance statistics.

homoplasy.bin <- function(
  rhi_vals, 
  abs_val_min = 20, 
  intervals = seq(0, 1, 0.1),
  round_digits = 3,
  min_bin_size = 1,
  excluded = integer(0),
  plot = TRUE
){
  # --- Exclusion logic with frame shift and unique naming ---
  N <- length(rhi_vals)
  orig_names <- names(rhi_vals)
  if(is.null(orig_names)) orig_names <- as.character(seq_len(N))
  if(length(excluded) > 0){
    excluded <- sort(unique(as.integer(excluded)))
    N_full <- N + length(excluded)
    full_vals <- rep(NA_real_, N_full)
    not_excluded <- setdiff(seq_len(N_full), excluded)
    full_vals[not_excluded] <- rhi_vals
    rhi_vals <- full_vals
    names_rhi <- as.character(seq_len(N_full))
    N <- N_full
  } else {
    names_rhi <- orig_names
    if(is.null(names_rhi)) names_rhi <- as.character(seq_len(N))
  }
  
  # --- Binning logic ---
  rhi_rounded <- round(rhi_vals, digits = round_digits)
  tab <- table(rhi_rounded, useNA = "no")
  abs_val_bins <- names(tab)[tab >= abs_val_min]
  bin_labels <- character(0)
  bin_list <- list()
  used <- rep(FALSE, N)
  
  # Assign values that meet threshold to their own abs_val bin.
  # These bins will contain only values that, after rounding, are exactly equal to the bin value.
  for(val in abs_val_bins) {
    idx <- which(rhi_rounded == as.numeric(val))
    binname <- paste0("=", val)
    bin_labels <- c(bin_labels, binname)
    bin_list[[binname]] <- names_rhi[idx]
    used[idx] <- TRUE
  }
  
  # Remaining values: bin by intervals
  remaining_idx <- which(!used & !is.na(rhi_vals))
  remaining_vals <- rhi_vals[remaining_idx]
  remaining_names <- names_rhi[remaining_idx]
  bin_map <- character(length(remaining_idx))
  range_bins <- NULL
  if(length(remaining_vals) > 0){
    range_bins <- cut(remaining_vals, breaks = intervals, include.lowest = TRUE, right = FALSE)
    bin_map <- as.character(range_bins)
    for(lbl in levels(range_bins)){
      idx <- which(range_bins == lbl)
      if(length(idx) > 0){
        bin_labels <- c(bin_labels, as.character(lbl))
        bin_list[[as.character(lbl)]] <- remaining_names[idx]
      }
    }
  }
  
  na_idx <- which(is.na(rhi_vals))
  if(length(na_idx) > 0){
    bin_list[["NA"]] <- names_rhi[na_idx]
    bin_labels <- c(bin_labels, "NA")
  }
  
  # --- Merge small bins ---
  # Only interval bins are merged if under min_bin_size, NEVER merge small bins into abs_val bins.
  # abs_val bins always remain strictly for their unique value.
  bin_sizes <- sapply(bin_list, length)
  too_small <- which(bin_sizes < min_bin_size & names(bin_list) != "NA")
  if(length(too_small) > 0 && length(bin_list) > 1){
    # Only merge interval bins; do NOT merge abs_val bins
    interval_bin_names <- setdiff(names(bin_list),
                                  c(names(bin_list)[startsWith(names(bin_list), "=")], "NA"))
    interval_bin_centers <- sapply(interval_bin_names, function(lbl){
      nums <- as.numeric(unlist(regmatches(lbl, gregexpr("[0-9.]+", lbl))))
      if(length(nums) == 2) mean(nums) else NA_real_
    })
    for(idx in too_small){
      lbl <- names(bin_list)[idx]
      vals <- bin_list[[lbl]]
      if(length(vals) == 0) next
      # Merge only if this bin is an interval bin
      if(lbl %in% interval_bin_names){
        nums <- as.numeric(unlist(regmatches(lbl, gregexpr("[0-9.]+", lbl))))
        my_center <- if(length(nums) == 2) mean(nums) else NA_real_
        # Find closest other interval bin
        other_idxs <- setdiff(seq_along(interval_bin_names), which(interval_bin_names == lbl))
        dists <- abs(interval_bin_centers[other_idxs] - my_center)
        nearest_bin <- interval_bin_names[other_idxs[which.min(dists)]]
        bin_list[[nearest_bin]] <- c(bin_list[[nearest_bin]], vals)
        bin_list[[lbl]] <- character(0)
      }
      # If abs_val bin is too small, leave empty (do not merge)
    }
    # Remove empty bins except NA
    keep <- sapply(bin_list, length) > 0 | names(bin_list) == "NA"
    bin_list <- bin_list[keep]
  }
  
  # --- Safety check: print warning if an abs_val bin contains values not matching its label ---
  for(bn in names(bin_list)) {
    if(startsWith(bn, "=") && length(bin_list[[bn]]) > 0) {
      vals <- rhi_vals[as.integer(bin_list[[bn]])]
      rounded_vals <- round(vals, round_digits)
      lbl_val <- as.numeric(sub("^=", "", bn))
      if(any(rounded_vals != lbl_val)) {
        warning(sprintf("Bin %s contains non-matching values: %s", bn, paste(unique(rounded_vals), collapse=", ")))
      }
    }
  }
  
  # --- Summary statistics ---
stats_df <- do.call(rbind, lapply(names(bin_list), function(bn) {
  char_ids <- bin_list[[bn]]
  vals <- rhi_vals[as.integer(char_ids)]
  # n should count ALL char_ids, even if values are NA
  n_chars <- length(char_ids)
  vals_non_na <- vals[!is.na(vals)]
  data.frame(
    bin = bn,
    variance = if(length(vals_non_na) > 1) var(vals_non_na) else 0,
    mean = if(length(vals_non_na) > 0) mean(vals_non_na) else NA,
    sd = if(length(vals_non_na) > 1) sd(vals_non_na) else 0,
    n = n_chars
  )
}))
rownames(stats_df) <- NULL

  # --- Boxplot ---
  if(plot) {
    plot_list <- lapply(names(bin_list), function(bn) {
      ids <- bin_list[[bn]]
      ids <- ids[!is.na(ids)]
      vals <- rhi_vals[as.integer(ids)]
      vals <- vals[!is.na(vals)]
      vals
    })
    names(plot_list) <- names(bin_list)
    plot_list <- plot_list[sapply(plot_list, function(x) length(x) > 0)]
    if(length(plot_list) == 0) {
      message("No bins with values to plot.")
    } else {
      boxplot(plot_list,
              main="RHI Values by Homoplasy Bin",
              xlab="Bin",
              ylab="RHI Value",
              las=2,
              col="lightblue")
      abline(h=mean(rhi_vals, na.rm=TRUE), col="red", lty=2)
    }
  }
  
  return(list(
    bins = bin_list,
    stats = stats_df
  ))
}
