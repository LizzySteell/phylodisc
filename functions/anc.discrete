### 2025-Oct-29

### Wrapper function for reconstructing the ancestral states for an entire discrete character matrix. This function uses corHMM from the corHMM package.
### Uses Maximum likelihood to estimate ancestral states for nodes in a fully bifurcating phylogeny with branch-lengths (zero-length branches not allowed).
### This function calculates marginal likelihoods for characters, and the most likely state is selected based on the highest marginal scaled likelihood within each character (state likelihood).
### 
### FIXED: Now deals with polymorphisms and treats ambiguities as all possible states. Better because it includes more information from the dataset in the ancestral reconstruction.
### ER and SYM models supported, ARD model not advisable due to processing times and crashing. In most cases, ER produces best AICc scores for phylogenetic characters (from experimenting).
### FIXED dealing with character ordering via specific rate index matrices. Dependent on phylodisc::rate.index function.

anc.discrete <- function(matrix, tree, model="ER", ord=NULL){
	
	# Dependencies
  if(!requireNamespace("corHMM", quietly = TRUE)) stop("corHMM package required.")
  if(!exists("get.states", mode = "function")) stop("get.states() not found.")
  if(!exists("rate.index", mode = "function")) stop("rate.matrix() not found.")

# Tell user to convert all uncertainties to polymorphisms or ambiguities in preprocessing.
# Tell user to convert all gaps to ambiguities in preprocessing.
# Curly-brace uncertainty check
    if(any(grepl("\\{[^}]+\\}", mat, perl = TRUE))){
      msg <- "Uncertainty notation (curly braces) detected in input (e.g. '{01}').\n"
      msg <- paste0(msg, "Please preprocess your data before calling anc.discrete. Two common options:\n\n")
      msg <- paste0(msg, "1) Convert uncertainties to polymorphisms:\n   matrix2 <- uncert.to.poly(matrix)\n\n\n")
      msg <- paste0(msg, "2) Convert uncertainties to ambiguities '?':\n   matrix2 <- uncert.to.amb(matrix)\n\n")
      stop(msg)
    }
     # Invariant detection (vectorized)
  is_invariant <- function(col) {
    vals <- col[!is.na(col) & col != "?"]
    length(vals) == 0 || length(unique(vals)) == 1
  }
  inv_idx <- which(apply(matrix, 2, is_invariant))
  if(length(inv_idx) > 0){
    names <- colnames(matrix)
    if(!is.null(names)){
      stop(sprintf("Invariant characters detected (including one-state + ambiguity). These should be removed: %s. Please remove invariant characters (e.g. using remove.invar()) before running anc.discrete.", paste(names[inv_idx], collapse = ", ")))
    } else {
      stop(sprintf("Invariant characters detected at column indices: %s. Please remove invariant characters (e.g. using remove.invar()) before running anc.discrete.", paste(inv_idx, collapse = ", ")))
    }
  }

# Gaps are treated as ambiguities.
matrix[matrix == "-"] <- "?"

# Polymorphisms need to be encoded differently to be read properly by corHMM

replace_poly <- function(x) {
  # Replace patterns like "(01)", "(23)", etc. with "0&1", "2&3", etc.
  gsub("\\((\\d)(\\d)\\)", "\\1&\\2", x)
}

mat_new <- replace_poly(matrix)


# Subfunction to reconstruct ancestral state for each character.

anc.discrete.char <- function(tree, char, model, rate_index, ord){
	
	# Check if this character is ordered
	if (!is.null(ord) && rate_index %in% ord) {
		# Use custom rate index matrix for ordered characters
		rate_mat <- rate.index(char[,2], model=model)
		anc <- corHMM(tree, char, model=model, rate.cat=1, rate.mat=rate_mat)
	} else {
		# Default behavior
		anc <- corHMM(tree, char, model=model, rate.cat=1)
	}
	
	liks <- anc$states
	
	anc_nodes <- cbind(liks, c(seq(1:dim(liks)[1])))
anc_nodes <- anc_nodes[,-c(1:dim(liks)[2])]

# # Select most likely state for each node based on the marginal scaled likelihoods for each state in each character and shift output by -1 so it reflects original character scorings.
for(i in 1:length(anc_nodes)){
	anc_nodes[[i]] <- as.numeric(which.max(liks[i,])) -1
}

return(anc_nodes)

}

# Make a list of dataframes that contain one character each

char_dfs <- list()

for (i in seq_len(ncol(mat_new))) {
  # Combine rownames and character column, with sequential row names
  df <- data.frame(
    V1 = rownames(mat_new),
    V2 = mat_new[, i],
    stringsAsFactors = FALSE
  )
  rownames(df) <- seq_len(nrow(df))
  char_dfs[[i]] <- df
}

# Reconstruct ancestral states for every character in the matrix.
	
# Reconstruct ancestral states for every character in the matrix.
nodes <- lapply(seq_along(char_dfs), function(i) {
  anc.discrete.char(tree, char_dfs[[i]], model, i, ord)
})



anc_states <- matrix(unlist(nodes), ncol=length(nodes), byrow=FALSE)
row.names(anc_states) <- as.character(c(1:(length(tree$tip.label)-1)+length(tree$tip.label)))


# Returns a matrix of ancestral character states for each node, ordered in the same order as specified in the tree (phylo object).
return(anc_states)

}
