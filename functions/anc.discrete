### 2025-Oct-29

### Wrapper function for reconstructing the ancestral states for an entire discrete character matrix. This function uses ace() from the 'ape' package.
### Maximum likelihood is only option for estimating ancestral states for discrete characters. Currently, only an equal rates model of character state evolution is available for this function.
### This function opts for marginal likelihood = FALSE, which has been pointed out by L. Revell that it actually generates marginal likelihood scores (see https://blog.phytools.org/2015/05/about-how-acemarginaltrue-does-not.html)
### A major drawback for this function is how polymorphic character scorings are treated. The ace function does not deal with polymorphic states. It can deal with missing data (encoded as NA).
### Here, polymorphisms are converted to ambiguities and all amgiguities (and gap scores) are treated as missing data (NA).
### This could be improved in the future by a new custom function that works with the phangorn PhyDat object, where polymorphisms are encoded using a contrast matrix.
### Another caveat is that ordered characters are ignored.

#### WORK IN PROGRESS

anc.discrete <- function(matrix, tree, model="ER"){
	
	# Dependencies
  if(!requireNamespace("corHMM", quietly = TRUE)) stop("corHMM package required.")
  if(!exists("get.states", mode = "function")) stop("get.states() not found.")
  if(!exists("rate.matrix", mode = "function")) stop("rate.matrix() not found.")

# Tell user to convert all uncertainties to polymorphisms or ambiguities in preprocessing.
# Tell user to convert all gaps to ambiguities in preprocessing.
# Curly-brace uncertainty check
    if(any(grepl("\\{[^}]+\\}", mat, perl = TRUE))){
      msg <- "Uncertainty notation (curly braces) detected in input (e.g. '{01}').\n"
      msg <- paste0(msg, "Please preprocess your data before calling anc.discrete. Two common options:\n\n")
      msg <- paste0(msg, "1) Convert uncertainties to polymorphisms:\n   matrix2 <- uncert.to.poly(matrix)\n\n\n")
      msg <- paste0(msg, "2) Convert uncertainties to ambiguities '?':\n   matrix2 <- uncert.to.amb(matrix)\n\n")
      stop(msg)
    }
     # Invariant detection (vectorized)
  is_invariant <- function(col) {
    vals <- col[!is.na(col) & col != "?"]
    length(vals) == 0 || length(unique(vals)) == 1
  }
  inv_idx <- which(apply(matrix, 2, is_invariant))
  if(length(inv_idx) > 0){
    names <- colnames(matrix)
    if(!is.null(names)){
      stop(sprintf("Invariant characters detected (including one-state + ambiguity). These should be removed: %s. Please remove invariant characters (e.g. using remove.invar()) before running anc.discrete.", paste(names[inv_idx], collapse = ", ")))
    } else {
      stop(sprintf("Invariant characters detected at column indices: %s. Please remove invariant characters (e.g. using remove.invar()) before running anc.discrete.", paste(inv_idx, collapse = ", ")))
    }
  }

# Gaps are treated as ambiguities.
matrix[matrix == "-"] <- "?"

# Polymorphisms need to be encoded differently to be read properly by corHMM

replace_poly <- function(x) {
  # Replace patterns like "(01)", "(23)", etc. with "0&1", "2&3", etc.
  gsub("\\((\\d)(\\d)\\)", "\\1&\\2", x)
}

mat_new <- replace_poly(matrix)


# Subfunction to reconstruct ancestral state for each character.

anc.discrete.char <- function(char, tree, model){
	
	# Anc state reconstruction for one character in the matrix using corHMM
	anc <- corHMM(tree, char, model=model, rate.cat=1)
	
	liks <- anc$states
	
	anc_nodes <- cbind(liks, c(seq(1:dim(liks)[1])))
anc_nodes <- anc_nodes[,-c(1:dim(liks)[2])]

# Select the character state with the highest probability for each node (ancestor).
for(i in 1:length(anc_nodes)){
	anc_nodes[[i]] <- as.numeric(which.max(liks[i,]))
}

return(anc_nodes)

}

# Make a list of dataframes that contain one character each

char_dfs <- list()

for (i in seq_len(ncol(mat_new))) {
  # Combine rownames and character column, with sequential row names
  df <- data.frame(
    V1 = rownames(mat_new),
    V2 = mat_new[, i],
    stringsAsFactors = FALSE
  )
  rownames(df) <- seq_len(nrow(df))
  char_dfs[[i]] <- df
}

# Reconstruct ancestral states for every character in the matrix.
	
	nodes <- lapply(char_dfs, anc.discrete.char, tree, model=model)
	
	#troubleshooting
#	hmms <- list()
	# is corHMM working yes but lappy stops due to error, let's do forloop
#	for (i in 1:length(char_dfs)){
		
#	hmms[[i]] <- corHMM(tree, char_dfs[[i]], rate.cat=1, model="ER")
#	print(i)
#	}

# Select most likely state for each node based on the marginal scaled likelihoods for each state in each character.
anc_states <- matrix(unlist(nodes), ncol=length(nodes), byrow=FALSE)
row.names(anc_states) <- as.character(c(1:(length(tree$tip.label)-1)+length(tree$tip.label)))


# Returns a matrix of ancestral character states for each node, ordered in the same order as specified in the tree (phylo object).
return(anc_states)

}
